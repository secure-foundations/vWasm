module Wasm.Parse.Limits

(* This file has been automatically generated by EverParse. *)
open FStar.Bytes
module U8 = FStar.UInt8
module U16 = FStar.UInt16
module U32 = FStar.UInt32
module U64 = FStar.UInt64
module LP = LowParse.Spec.Base
module LS = LowParse.SLow.Base
module LPI = LowParse.Spec.AllIntegers
module L = FStar.List.Tot
module BY = FStar.Bytes

open Wasm.Parse.Aux_max_present
open Wasm.Parse.Aux_only_min
open Wasm.Parse.Aux_min_max

type limits =
  | L_absent of aux_only_min
  | L_present of aux_min_max

inline_for_extraction let tag_of_limits (x:limits) : aux_max_present = match x with
  | L_absent _ -> Absent
  | L_present _ -> Present

inline_for_extraction noextract let limits_parser_kind = LP.strong_parser_kind 5 9 None

noextract val limits_parser: LP.parser limits_parser_kind limits

noextract val limits_serializer: LP.serializer limits_parser

noextract val limits_bytesize (x:limits) : GTot nat

noextract val limits_bytesize_eq (x:limits) : Lemma (limits_bytesize x == Seq.length (LP.serialize limits_serializer x))

val limits_parser32: LS.parser32 limits_parser

val limits_serializer32: LS.serializer32 limits_serializer

val limits_size32: LS.size32 limits_serializer

val limits_bytesize_eqn_absent (x: aux_only_min) : Lemma (limits_bytesize (L_absent x) == 1 + (aux_only_min_bytesize (x))) [SMTPat (limits_bytesize (L_absent x))]

val limits_bytesize_eqn_present (x: aux_min_max) : Lemma (limits_bytesize (L_present x) == 1 + (aux_min_max_bytesize (x))) [SMTPat (limits_bytesize (L_present x))]

