module Wasm.Parse.Limits

(* This file has been automatically generated by EverParse. *)
open FStar.Bytes
module U8 = FStar.UInt8
module U16 = FStar.UInt16
module U32 = FStar.UInt32
module U64 = FStar.UInt64
module LP = LowParse.Spec
module LS = LowParse.SLow
module LPI = LowParse.Spec.AllIntegers
module L = FStar.List.Tot
module BY = FStar.Bytes

#reset-options "--using_facts_from '* -FStar.Tactics -FStar.Reflection' --z3rlimit 16 --z3cliopt smt.arith.nl=false --max_fuel 2 --max_ifuel 2"

friend Wasm.Parse.Aux_max_present

// Need high Z3 limits for large sum types
#set-options "--z3rlimit 120"

inline_for_extraction unfold let aux_max_present_as_enum_key (x:aux_max_present) : Pure (LP.enum_key aux_max_present_enum)
  (requires norm [delta; zeta; iota; primops] (LP.list_mem x (LP.list_map fst aux_max_present_enum)) == true) (ensures fun _ -> True) =
  [@inline_let] let _ = norm_spec [delta; zeta; iota; primops] (LP.list_mem x (LP.list_map fst aux_max_present_enum)) in x

inline_for_extraction let key_of_limits (x:limits) : LP.enum_key aux_max_present_enum =
  match x with
  | L_absent _ -> aux_max_present_as_enum_key Absent
  | L_present _ -> aux_max_present_as_enum_key Present

inline_for_extraction let limits_case_of_aux_max_present (x:aux_max_present) : Type0 =
  match x with
  | Absent -> aux_only_min
  | Present -> aux_min_max

unfold inline_for_extraction let to_limits_case_of_aux_max_present (x:aux_max_present) (#x':aux_max_present) (y:limits_case_of_aux_max_present x')  : Pure (norm [delta_only [(`%limits_case_of_aux_max_present)]; iota] (limits_case_of_aux_max_present x))
  (requires (x == x')) (ensures (fun y' -> y' == y)) =
  [@inline_let] let _ = norm_spec [delta_only [(`%limits_case_of_aux_max_present)] ; iota] (limits_case_of_aux_max_present x) in y

unfold inline_for_extraction let limits_refine (k:LP.enum_key aux_max_present_enum) (x:limits)
  : Pure (LP.refine_with_tag key_of_limits k)  (requires norm [delta; iota; zeta] (key_of_limits x) == k) (ensures (fun y -> y == x)) =
  [@inline_let] let _ = norm_spec [delta; iota; zeta] (key_of_limits x) in x

inline_for_extraction let synth_limits_cases (x:LP.enum_key aux_max_present_enum) (y:limits_case_of_aux_max_present x)
  : LP.refine_with_tag key_of_limits x =
  match x with
  | Absent -> limits_refine x (L_absent (to_limits_case_of_aux_max_present Absent y))
  | Present -> limits_refine x (L_present (to_limits_case_of_aux_max_present Present y))

unfold inline_for_extraction let from_limits_case_of_aux_max_present (#x':aux_max_present) (x:aux_max_present)
  (y: norm [delta_only [(`%limits_case_of_aux_max_present)]; iota] (limits_case_of_aux_max_present x))
  : Pure (limits_case_of_aux_max_present x') (requires (x == x')) (ensures (fun y' -> y' == y)) =
  [@inline_let] let _ = norm_spec [delta_only [(`%limits_case_of_aux_max_present)] ; iota] (limits_case_of_aux_max_present x) in y

let synth_limits_cases_recip_pre (k:LP.enum_key aux_max_present_enum)
  (x:LP.refine_with_tag key_of_limits k) : GTot bool =
  match k with
  | Absent -> L_absent? x
  | Present -> L_present? x

let synth_limits_cases_recip_pre_intro (k:LP.enum_key aux_max_present_enum) (x:LP.refine_with_tag key_of_limits k)
  : Lemma (synth_limits_cases_recip_pre k x == true) =
  norm_spec [delta; iota] (synth_limits_cases_recip_pre k x)

inline_for_extraction let synth_limits_cases_recip (k:LP.enum_key aux_max_present_enum)
  (x:LP.refine_with_tag key_of_limits k) : (limits_case_of_aux_max_present k) =
  match k with
  | Absent -> [@inline_let] let _ = synth_limits_cases_recip_pre_intro Absent x in
    (match x with L_absent y -> (from_limits_case_of_aux_max_present Absent y))
  | Present -> [@inline_let] let _ = synth_limits_cases_recip_pre_intro Present x in
    (match x with L_present y -> (from_limits_case_of_aux_max_present Present y))

inline_for_extraction let limits_sum = LP.make_sum' aux_max_present_enum key_of_limits
  limits_case_of_aux_max_present synth_limits_cases synth_limits_cases_recip
  (_ by (LP.make_sum_synth_case_recip_synth_case_tac ()))
  (_ by (LP.synth_case_synth_case_recip_tac ()))

noextract let parse_limits_cases (x:LP.sum_key limits_sum)
  : k:LP.parser_kind & LP.parser k (limits_case_of_aux_max_present x) =
  match x with
  | Absent -> [@inline_let] let u : (k: LP.parser_kind & LP.parser k (limits_case_of_aux_max_present Absent)) = (| _, aux_only_min_parser |) in u
  | Present -> [@inline_let] let u : (k: LP.parser_kind & LP.parser k (limits_case_of_aux_max_present Present)) = (| _, aux_min_max_parser |) in u
  | _ -> (| _, LP.parse_false |)

noextract let serialize_limits_cases (x:LP.sum_key limits_sum)
  : LP.serializer (dsnd (parse_limits_cases x)) =
  match x with
  | Absent -> [@inline_let] let u : LP.serializer (dsnd (parse_limits_cases Absent)) = aux_only_min_serializer in u
  | Present -> [@inline_let] let u : LP.serializer (dsnd (parse_limits_cases Present)) = aux_min_max_serializer in u
  | _ -> LP.serialize_false

inline_for_extraction noextract let parse32_limits_cases (x:LP.sum_key limits_sum)
  : LS.parser32 (dsnd (parse_limits_cases x)) =
  match x with
  | Absent -> [@inline_let] let u : LS.parser32 (dsnd (parse_limits_cases Absent)) = aux_only_min_parser32 in u
  | Present -> [@inline_let] let u : LS.parser32 (dsnd (parse_limits_cases Present)) = aux_min_max_parser32 in u
  | _ -> LS.parse32_false

inline_for_extraction noextract let serialize32_limits_cases (x:LP.sum_key limits_sum)
  : LS.serializer32 (serialize_limits_cases x) =
  match x with
  | Absent -> [@inline_let] let u : LS.serializer32 (serialize_limits_cases Absent) = aux_only_min_serializer32 in u
  | Present -> [@inline_let] let u : LS.serializer32 (serialize_limits_cases Present) = aux_min_max_serializer32 in u
  | _ -> LS.serialize32_false

inline_for_extraction noextract let size32_limits_cases (x:LP.sum_key limits_sum)
  : LS.size32 (serialize_limits_cases x) =
  match x with
  | Absent -> [@inline_let] let u : LS.size32 (serialize_limits_cases Absent) = aux_only_min_size32 in u
  | Present -> [@inline_let] let u : LS.size32 (serialize_limits_cases Present) = aux_min_max_size32 in u
  | _ -> LS.size32_false

let limits_parser =
  assert_norm (LP.parse_sum_kind (LP.get_parser_kind aux_max_present_repr_parser) limits_sum parse_limits_cases == limits_parser_kind);
  LP.parse_sum limits_sum aux_max_present_repr_parser parse_limits_cases

let limits_serializer =
  assert_norm (LP.parse_sum_kind (LP.get_parser_kind aux_max_present_repr_parser) limits_sum parse_limits_cases == limits_parser_kind);
  LP.serialize_sum limits_sum aux_max_present_repr_serializer serialize_limits_cases

let limits_bytesize (x:limits) : GTot nat = Seq.length (limits_serializer x)

let limits_bytesize_eq x = ()

let limits_parser32 =
  assert_norm (LP.parse_sum_kind (LP.get_parser_kind aux_max_present_repr_parser) limits_sum parse_limits_cases == limits_parser_kind);
  LS.parse32_sum2 limits_sum aux_max_present_repr_parser aux_max_present_repr_parser32 parse_limits_cases parse32_limits_cases (_ by (LP.enum_destr_tac aux_max_present_enum)) (_ by (LP.maybe_enum_key_of_repr_tac aux_max_present_enum))

let limits_serializer32 =
  assert_norm (LP.parse_sum_kind (LP.get_parser_kind aux_max_present_repr_parser) limits_sum parse_limits_cases == limits_parser_kind);
  assert_norm (LS.serializer32_sum_gen_precond (LP.get_parser_kind aux_max_present_repr_parser) (LP.weaken_parse_cases_kind limits_sum parse_limits_cases));
  LS.serialize32_sum2 limits_sum aux_max_present_repr_serializer aux_max_present_repr_serializer32 serialize_limits_cases serialize32_limits_cases (_ by (LP.dep_enum_destr_tac ())) (_ by (LP.enum_repr_of_key_tac aux_max_present_enum)) ()

let limits_size32 =
  assert_norm (LP.parse_sum_kind (LP.get_parser_kind aux_max_present_repr_parser) limits_sum parse_limits_cases == limits_parser_kind);
  assert_norm (LS.size32_sum_gen_precond (LP.get_parser_kind aux_max_present_repr_parser) (LP.weaken_parse_cases_kind limits_sum parse_limits_cases));
  LS.size32_sum2 limits_sum aux_max_present_repr_serializer aux_max_present_repr_size32 serialize_limits_cases size32_limits_cases (_ by (LP.dep_enum_destr_tac ())) (_ by (LP.enum_repr_of_key_tac aux_max_present_enum)) ()

let limits_bytesize_eqn_absent x =
    assert_norm (LP.parse_sum_kind (LP.get_parser_kind aux_max_present_repr_parser) limits_sum parse_limits_cases == limits_parser_kind);

  LP.serialize_sum_eq limits_sum aux_max_present_repr_serializer serialize_limits_cases (L_absent x);
  (let ln = FStar.Seq.length (LP.serialize (LP.serialize_enum_key _ aux_max_present_repr_serializer (LP.sum_enum limits_sum)) (key_of_limits (L_absent x))) in assert (1 <= ln /\ ln <= 1));
  (aux_only_min_bytesize_eq (x))

let limits_bytesize_eqn_present x =
    assert_norm (LP.parse_sum_kind (LP.get_parser_kind aux_max_present_repr_parser) limits_sum parse_limits_cases == limits_parser_kind);

  LP.serialize_sum_eq limits_sum aux_max_present_repr_serializer serialize_limits_cases (L_present x);
  (let ln = FStar.Seq.length (LP.serialize (LP.serialize_enum_key _ aux_max_present_repr_serializer (LP.sum_enum limits_sum)) (key_of_limits (L_present x))) in assert (1 <= ln /\ ln <= 1));
  (aux_min_max_bytesize_eq (x))

